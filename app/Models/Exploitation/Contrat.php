<?php

namespace App\Models\Exploitation;

use App\Enums\StatusContrat;
use App\Enums\TypeContrat;
use App\Models\Architecture\ServiceAnnexe;
use App\Models\Architecture\TypeEquipement;
use App\Models\Finance\Facture;
use App\Models\Scopes\OwnSiteScope;
use App\Models\Scopes\RecentScope;
use App\Traits\HasEmplacement;
use App\Traits\HasOwnerScope;
use App\Traits\HasResponsible;
use App\Traits\HasSites;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\SoftDeletes;
use OwenIt\Auditing\Contracts\Auditable;
use Spatie\MediaLibrary\HasMedia;
use Spatie\MediaLibrary\InteractsWithMedia;
use Spatie\ModelStatus\HasStatuses;
use Staudenmeir\EloquentHasManyDeep\HasManyDeep;

/**
 * @mixin IdeHelperContrat
 */
class Contrat extends Model implements HasMedia, Auditable
{
    use SoftDeletes, HasStatuses, HasResponsible, HasOwnerScope, HasSites, HasEmplacement, InteractsWithMedia;
    use \Staudenmeir\EloquentHasManyDeep\HasRelationships;
    use \OwenIt\Auditing\Auditable;

    protected $fillable = [
        'code', 'code_contrat', 'personne_id', 'site_id', 'debut', 'fin', 'annexe_id',
        'emplacement_id', 'attachment', 'avance', 'equipable', 'auto_valid',
    ];
    protected $dates = ['created_at'];
    /**
     * les propriétés qui doivent être caster.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'equipable' => 'boolean',
        'auto_valid' => 'boolean',
        'personne_id' => 'integer',
        'site_id' => 'integer',
        'annexe_id' => 'integer',
        'avance' => 'integer',
    ];
    protected $auditExclude = ['code', 'auto_valid', 'equipable'];
    protected $appends = ['type', 'status'];

    public const RULES = [
        'site_id' => 'required',
        'personne_id' => 'required',
        'debut' => 'required',
        'fin' => 'required',
    ];

    public const EDIT_RULES = [
        'avance' => 'required|numeric',
        'debut' => 'required',
        'fin' => 'required',
    ];

    protected static function booted(): void
    {
        static::addGlobalScope(new RecentScope);
        static::addGlobalScope(new OwnSiteScope);
    }

    /**
     *
     * @return Attribute<string, never>
     */
    protected function type(): Attribute
    {
        return Attribute::make(
            get: fn() => $this->attributes['annexe_id'] ? TypeContrat::ANNEXE : TypeContrat::BAIL
        );
    }

    public static function annexeRules(): array
    {
        return [ ...self::RULES, ...['annexe_id' => 'required']];
    }

    public static function bailRules(): array
    {
        return [ ...self::RULES, ...['emplacement_id' => 'required', 'avance' => 'required']];
    }

    public function isAnnexe(): bool
    {
        return !empty($this->attributes['annexe_id']);
    }

    public function isBail(): bool
    {
        return !empty($this->attributes['emplacement_id']);
    }

    public function codeGenerate(): void
    {
        $rang = $this->withTrashed()->count() + 1;
        $this->attributes['code'] = DEMANDE_CODE_PREFIXE . str_pad((string) $rang, 7, '0', STR_PAD_LEFT);
    }

    public function codeContratGenerate(): void
    {
        $this->attributes['code_contrat'] = CONTRAT_CODE_PREFIXE . substr($this->attributes['code'], 3, 7);
    }

    public function codification(): string
    {
        return $this->attributes['code_contrat'] ?? $this->attributes['code'];
    }

    public function attente(): void
    {
        $this->setStatus(StatusContrat::ATTENTE->value);
    }

    public function onValidated(): void
    {
        $this->setStatus(StatusContrat::ONVALIDATED->value);
    }

    public function endorsed(): void
    {
        $this->setStatus(StatusContrat::ONENDORSED->value);
    }

    public function validate(): void
    {
        $this->setStatus(StatusContrat::VALIDATED->value);
    }

    public function abort(): void
    {
        $this->setStatus(StatusContrat::ABORTED->value);
    }

    // scopes
    public function scopeIsAnnexe(Builder $query): Builder
    {
        return $query->whereNotNull('annexe_id');
    }

    public function scopeIsBail(Builder $query): Builder
    {
        return $query->whereNotNull('emplacement_id');
    }

    /**
     * obtenir les contrats validés
     */
    public function scopeValidated(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::VALIDATED->value);
    }

    /**
     * obtenir les contrats à valider
     */
    public function scopeOnValidated(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ONVALIDATED->value);
    }

    /**
     * obtenir les contrats à signer
     */
    public function scopeOnEndorsed(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ONENDORSED->value);
    }

    /**
     * obtenir les contrats en attente
     */
    public function scopeEnAttente(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ATTENTE->value);
    }

    /**
     * Obtenir les contrats résiliés
     */
    public function scopeAborted(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ABORTED->value);
    }

    /**
     * Obtenir les contrats qui ne sont pas résiliés
     */
    public function scopeNotAborted(Builder $query): Builder
    {
        return $query->otherCurrentStatus(StatusContrat::ABORTED->value);
    }

    /**
     * Obtenir les contrats qui sont encore dans le processus
     */
    public function scopeInProcess(Builder $query): Builder
    {
        return $query->otherCurrentStatus([StatusContrat::ABORTED->value, StatusContrat::VALIDATED->value]);
    }

    /**
     * Obtenir les contrats qui sont encore ordonnançable
     */
    public function scopeSchedulable(Builder $query): Builder
    {
        return $query->whereDoesntHave('ordonnancements', fn(Builder $query) => $query->unpaid())->inProcess();
    }

    /**
     * Obtenir les contrats qui sont à jour
     */
    public function scopeUptodate(Builder $query): Builder
    {
        return $query->whereHas('factures', fn(Builder $query) => $query->isPaid(), '=');
    }

    /**
     * Obtenir les contrats qui sont pas à jour
     */
    public function scopeNotuptodate(Builder $query): Builder
    {
        return $query->whereHas('factures', fn(Builder $query) => $query->isUnPaid());
    }

    /**
     * Obtenir les contrats appartenant à l'utilisateur courant
     *
     */
    public function scopeOwner(Builder $query, mixed $id): Builder
    {
        return $query->whereHas('audits', fn($query) => $query->where('user_id', $id));
    }

    public function scopeFilterBetweenStatusDate(Builder $query, ?array $dates): Builder
    {
        [$start, $end] = $dates;
        return $query->when($dates, fn(Builder $query): Builder => $query->whereHas('statuses', fn(Builder $query): Builder => $query->whereBetween('created_at', [$start, $end])));
    }

    // relations
    /**
     * Obtenir la personnne liée à un contrat
     */
    public function personne(): BelongsTo
    {
        return $this->belongsTo(Personne::class);
    }

    /**
     * Obtenir le service annexe d'un contrat annexe
     */
    public function annexe(): BelongsTo
    {
        return $this->belongsTo(ServiceAnnexe::class);
    }

    /**
     * Obtenir les factures d'un contrat (equipement, loyer, initial ou annexe)
     */
    public function factures(): HasMany
    {
        return $this->hasMany(Facture::class);
    }

    /**
     * Obtenir les factures d'equipement pour un contrat
     */
    public function facturesEquipements(): HasMany
    {
        return $this->hasMany(Facture::class)->isEquipement();
    }

    /**
     * Obtenir les factures de loyer pour un contrat
     */
    public function facturesLoyers(): HasMany
    {
        return $this->hasMany(Facture::class)->isLoyer();
    }

    /**
     * Obtenir la facture annexe d'un contrat
     */
    public function factureAnnexe(): HasOne
    {
        return $this->hasOne(Facture::class)->isAnnexe();
    }

    /**
     * Obtenir la facture initiale d'un contrat
     */
    public function factureInitiale(): HasOne
    {
        return $this->hasOne(Facture::class)->isInitiale();
    }

    /**
     * Les types d'équipement proposé pour un contrat
     */
    public function equipements(): BelongsToMany
    {
        return $this->belongsToMany(TypeEquipement::class, 'contrats_type_equipements', 'contrat_id', 'type_equipement_id')->withPivot('abonnable');
    }

    public function ordonnancements(): HasManyDeep
    {
        return $this->hasManyDeep(Ordonnancement::class,
            [Facture::class, Paiement::class], [null, null, 'id'], [null, null, 'ordonnancement_id']);
    }

    public function registerMediaCollections(): void
    {
        $this->addMediaCollection(COLLECTION_MEDIA_CONTRAT)->singleFile();
    }
}
