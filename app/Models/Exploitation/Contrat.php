<?php

namespace App\Models\Exploitation;

use App\Enums\StatusContrat;
use App\Enums\TypeContrat;
use App\Models\Architecture\ServiceAnnexe;
use App\Models\Architecture\TypeEquipement;
use App\Models\Finance\Facture;
use App\Traits\HasEmplacement;
use App\Traits\HasSites;
use App\Traits\RecentOrder;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\SoftDeletes;
use Spatie\ModelStatus\HasStatuses;

/**
 * @mixin IdeHelperContrat
 */
class Contrat extends Model
{
    use SoftDeletes, HasStatuses, HasSites, HasEmplacement, RecentOrder;

    protected $fillable = [
        'code', 'personne_id', 'site_id', 'debut', 'fin', 'annexe_id',
        'emplacement_id', 'attachment', 'avance', 'equipable', 'auto_valid',
    ];
    /**
     * les propriétés qui doivent être caster.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'equipable' => 'boolean',
        'auto_valid' => 'boolean',
        'personne_id' => 'integer',
        'site_id' => 'integer',
        'annexe_id' => 'integer',
        'avance' => 'integer',
    ];
    /**
     *
     * @var array<int, string>
     */
    protected $appends = ['type', 'status'];

    public const RULES = [
        'site_id' => 'required',
        'personne_id' => 'required',
        'debut' => 'required',
        'fin' => 'required',
    ];

    public const EDIT_RULES = [
        'avance' => 'required|numeric',
        'debut' => 'required',
        'fin' => 'required',
    ];

    /**
     *
     * @return Attribute<string, never>
     */
    protected function type(): Attribute
    {
        return Attribute::make(
            get: fn () => $this->attributes['annexe_id'] ? TypeContrat::ANNEXE : TypeContrat::BAIL
        );
    }

    /**
     *
     * @return array<string, string>
     */
    public static function annexeRules(): array
    {
        return [...self::RULES, ...['annexe_id' => 'required']];
    }

    /**
     *
     * @return array<string, string>
     */
    public static function bailRules(): array
    {
        return [...self::RULES, ...['emplacement_id' => 'required', 'avance' => 'required']];
    }

    public function isAnnexe(): bool
    {
        return !empty($this->attributes['annexe_id']);
    }

    public function isBail(): bool
    {
        return !empty($this->attributes['emplacement_id']);
    }

    public function codeGenerate(): void
    {
        $rang = $this->withTrashed()->count() + 1;
        $this->attributes['code'] = CONTRAT_CODE_PREFIXE . str_pad((string) $rang, 7, '0', STR_PAD_LEFT);
    }

    public function attente(): void
    {
        $this->setStatus(StatusContrat::ATTENTE->value);
    }

    public function onValidated(): void
    {
        $this->setStatus(StatusContrat::ONVALIDATED->value);
    }

    public function endorsed(): void
    {
        $this->setStatus(StatusContrat::ONENDORSED->value);
    }

    public function validated(): void
    {
        $this->setStatus(StatusContrat::VALIDATED->value);
    }

    public function aborted(): void
    {
        $this->setStatus(StatusContrat::ABORTED->value);
    }

    // scopes

    /**
     * Undocumented function
     *
     * @param  Builder<Contrat>  $query
     * @return Builder<Contrat>
     */
    public function scopeIsAnnexe(Builder $query): Builder
    {
        return $query->whereNotNull('annexe_id');
    }
    /**
     * Undocumented function
     *
     * @param  Builder<Contrat>  $query
     * @return Builder<Contrat>
     */
    public function scopeIsBail(Builder $query): Builder
    {
        return $query->whereNotNull('emplacement_id');
    }

    /**
     * obtenir les contrats validés
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeValidated(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::VALIDATED->value);
    }
    /**
     * obtenir les contrats à valider
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeOnValidated(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ONVALIDATED->value);
    }

    /**
     * obtenir les contrats à signer
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeOnEndorsed(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ONENDORSED->value);
    }

    /**
     * obtenir les contrats en attente
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeEnAttente(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ATTENTE->value);
    }

    /**
     * Obtenir les contrats résiliés
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeAborted(Builder $query): Builder
    {
        return $query->currentStatus(StatusContrat::ABORTED->value);
    }

    /**
     * Obtenir les contrats qui ne sont pas résiliés
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeNotAborted(Builder $query): Builder
    {
        return $query->otherCurrentStatus(StatusContrat::ABORTED->value);
    }

    /**
     * Obtenir les contrats qui sont encore dans le processus
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeInProcess(Builder $query): Builder
    {
        return $query->otherCurrentStatus([StatusContrat::ABORTED->value, StatusContrat::VALIDATED->value]);
    }

    /**
     * Obtenir les contrats qui sont encore ordonnançable
     *
     * @param Builder<Contrat> $query
     * @return Builder<Contrat>
     */
    public function scopeSchedulable(Builder $query): Builder
    {
        return $query->otherCurrentStatus([StatusContrat::ABORTED->value, StatusContrat::ATTENTE->value]);
    }

    /**
     * Obtenir les contrats qui sont à jour
     *
     * @param Builder<Contrat> $query
     * @return Builder<Facture>
     */
    public function scopeUptodate(Builder $query): Builder
    {
        return $query->whereHas('factures', fn (Builder $query) => $query->isPaid(), '=');
    }

    /**
     * Obtenir les contrats qui sont pas à jour
     *
     * @param Builder<Contrat> $query
     * @return Builder<Facture>
     */
    public function scopeNotuptodate(Builder $query): Builder
    {
        return $query->whereHas('factures', fn (Builder $query) => $query->isUnPaid());
    }

    // relations
    /**
     * Obtenir la personnne liée à un contrat
     *
     * @return BelongsTo<Personne, Contrat>
     */
    public function personne(): BelongsTo
    {
        return $this->belongsTo(Personne::class);
    }

    /**
     * Obtenir le service annexe d'un contrat annexe
     *
     * @return BelongsTo<ServiceAnnexe, Contrat>
     */
    public function annexe(): BelongsTo
    {
        return $this->belongsTo(ServiceAnnexe::class);
    }

    /**
     * Obtenir les factures d'un contrat (equipement, loyer, initial ou annexe)
     *
     * @return HasMany<Facture>
     */
    public function factures(): HasMany
    {
        return $this->hasMany(Facture::class);
    }

    /**
     * Obtenir les factures d'equipement pour un contrat
     *
     * @return HasMany<Facture>
     */
    public function facturesEquipements(): HasMany
    {
        return $this->hasMany(Facture::class)->isEquipement();
    }

    /**
     * Obtenir les factures de loyer pour un contrat
     *
     * @return HasMany<Facture>
     */
    public function facturesLoyers(): HasMany
    {
        return $this->hasMany(Facture::class)->isLoyer();
    }

    /**
     * Obtenir la facture annexe d'un contrat
     *
     * @return HasOne<Facture>
     */
    public function factureAnnexe(): HasOne
    {
        return $this->hasOne(Facture::class)->isAnnexe();
    }

    /**
     * Obtenir la facture initiale d'un contrat
     *
     * @return HasOne<Facture>
     */
    public function factureInitiale(): HasOne
    {
        return $this->hasOne(Facture::class)->isInitiale();
    }

    /**
     * Les types d'équipement proposé pour un contrat
     *
     * @return BelongsToMany<TypeEquipement>
     */
    public function equipements(): BelongsToMany
    {
        return $this->belongsToMany(TypeEquipement::class, 'contrats_type_equipements', 'contrat_id', 'type_equipement_id')->withPivot('abonnable');
    }
}
